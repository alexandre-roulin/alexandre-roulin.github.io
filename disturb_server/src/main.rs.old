use bevy::prelude::*;
use bevy::{
    app::ScheduleRunnerSettings,
    prelude::App,
    prelude::{EventReader, ResMut},
    MinimalPlugins,
};
use bevy_networking_turbulence::{NetworkEvent, NetworkResource, NetworkingPlugin};
use disturb_shared::{BallId, ClientMessage, ServerMessage};
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Serialize, Deserialize)]
struct NetworkHandle(u32);

fn main() {
    App::build()
        .insert_resource(ScheduleRunnerSettings::run_loop(Duration::from_millis(
            1000 / 30,
        )))
        .add_plugins(MinimalPlugins)
        .add_plugin(NetworkingPlugin::default())
        .add_startup_system(disturb_shared::network_channels_setup.system())
        .add_startup_system(server_setup_system.system())
        .add_system(handle_network_events_system.system())
        .run();
}

fn server_setup_system(mut net: ResMut<NetworkResource>) {
    let socket_address = "0.0.0.0:5222".parse().expect("cannot parse ip");
    println!("Listening... {:?}", socket_address);
    net.listen(socket_address, None, None);
}

fn read_network_channels_system(mut net: ResMut<NetworkResource>) {
    for (_, connection) in net.connections.iter_mut() {
        let channels = connection.channels().unwrap();

        while let Some(message) = channels.recv::<ClientMessage>() {
            println!("Received message: {:?}", message);
        }
    }
}

fn handle_network_events_system(
    mut cmd: Commands,
    mut net: ResMut<NetworkResource>,
    mut network_event_reader: EventReader<NetworkEvent>,
    unowned_balls: Query<(Entity, &BallId), Without<NetworkHandle>>,
) {
    for event in network_event_reader.iter() {
        match event {
            NetworkEvent::Connected(handle) => match net.connections.get_mut(handle) {
                Some(_connection) => {
                    println!("New connection handle: {:?}", &handle);

                    let (entity, ball) = unowned_balls.iter().next().expect("No unowned balls");
                    cmd.entity(entity).insert(NetworkHandle(*handle));
                    net.send_message(*handle, ServerMessage::Welcome(*ball))
                        .expect("Could not send welcome");
                }
                None => panic!("Got packet for non-existing connection [{}]", handle),
            },
            _ => {}
        }
    }
}
